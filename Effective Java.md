# 对象的创建和销毁

### 一、使用静态工厂方法代替构造器

1. 静态工厂优势一：有名称。当一个类需要多个带有相同签名的构造器时，可以通过名称突出它们之间的区别
2. 静态工程优势二：不必每次都创建新的对象。可以将创建的实例缓存，或者是返回预先构建好的实例(工厂模式)。例如 `Boolean.valueOf(boolean)`。如果确保了每次返回的都是同一对象的话，可以使用`==`进行判断，提升效率
3. 静态工厂优势三：可以返回原返回类型的任何子类的对象，可以返回受保护的类的对象。例如`Collections.singletonList(T)`、`EnumSet`。

### 二、遇到多个构造器参数时要考虑用构造器

​	Builder 模式。这个就不必多少了，当构造器参数很多，并且都是可选时，推荐使用builder。也可以提供一个`DefaultInstance`，返回具有默认参数的对象。推荐一个工具 [lombok](https://www.projectlombok.org/) ,使用注解生成样板代码。

###  三、使用私有构造器或者枚举类型强化 Singleton 属性

​	使构造器私有，通过创建`getInstance`方法，返回该类的唯一`private static final`的实例。好处在于，在不改变API的前提下，可以改变方法实现，从而对类是否为`Singleton`。但是客户端可以使用`AccessibleObject.setAccessible`方法，通过反射调用私有构造器。

​	实现`Singleton`还可以使用`Enum`。

### 四、通过私有构造器强化不可变实例化的能力

​	例如工具类，不希望客户端对它进行实例化（实例化没有任何意义），可以创建私有的无参构造函数进行屏蔽对象的创建。NERVER：企图通过做成抽象类来强制该类不能被实例化，这样会引起误解。

### 五、避免创建不必要的对象

1. 避免 `String s = new String("***")`的操作

2. 需要重复使用的对象，应该将实例进行缓存，而不是每次都创建。例如判断一个人是否为2000年后出生，应该将`2000-1-1`进行缓存，再和他的出生日期进行比较

3. `适配器模式`中，没有必要创建多个适配器对象。例如`Map.keySet()`方法，就会将`ks`对象进行缓存。每次都返回同一个对象

4. 避免大量的`自动装箱`操作。

   ```java
   Long sum = 0L; 	// 使用 long sum = 0L 可以避免自动装箱，节省大量资源
   for(long  i = 0; i < Integer.MAX_VALUE; i ++) {
       sum += i;
   }
   ```

   

